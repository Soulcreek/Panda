(function () {
  function buildHeaders(opts) {
    const h = opts && opts.headers ? { ...opts.headers } : {};
    if (opts && opts.json && !h['Content-Type']) h['Content-Type'] = 'application/json';
    if (opts && opts.csrf && window.CSRF_TOKEN) {
      h['CSRF-Token'] = window.CSRF_TOKEN;
    }
    return h;
  }
  async function apiFetch(url, opts) {
    opts = opts || {};
    const method = (opts.method || (opts.json ? 'POST' : 'GET')).toUpperCase();
    const maxRetries =
      method === 'GET'
        ? typeof opts.retry === 'number'
          ? opts.retry
          : opts.retry
            ? opts.retry.retries
            : 2
        : 0;
    const retryDelayBase = (opts.retry && opts.retry.delayMs) || 300;
    let attempt = 0;
    let lastErr;
    while (true) {
      const fetchOpts = {
        method,
        headers: buildHeaders(opts),
        body: undefined,
        credentials: 'same-origin',
      };
      if (opts.json) fetchOpts.body = JSON.stringify(opts.json);
      let resp, text;
      try {
        resp = await fetch(url, fetchOpts);
      } catch (e) {
        lastErr = new Error('Netzwerkfehler: ' + e.message);
        if (attempt < maxRetries) {
          await new Promise((r) => setTimeout(r, retryDelayBase * Math.pow(2, attempt)));
          attempt++;
          continue;
        }
        throw lastErr;
      }
      const ct = resp.headers.get('content-type') || '';
      if (!resp.ok) {
        if (method === 'GET' && resp.status >= 500 && resp.status !== 501 && attempt < maxRetries) {
          attempt++;
          await new Promise((r) => setTimeout(r, retryDelayBase * Math.pow(2, attempt - 1)));
          continue;
        }
      }
      if (!ct.includes('application/json')) {
        text = await resp.text();
        if (!resp.ok) {
          const plainErr = new Error('HTTP ' + resp.status + '(kein JSON)');
          plainErr.status = resp.status;
          throw plainErr;
        }
        return { raw: text };
      }
      const data = await resp.json();
      if (!resp.ok) {
        const err = new Error(data.error || data.message || 'HTTP ' + resp.status);
        err.status = resp.status;
        err.payload = data;
        throw err;
      }
      return data;
    }
  }
  function formatError(e) {
    if (!e) return 'Unbekannter Fehler';
    if (e.payload) {
      let msg = e.payload.error || e.message || 'Fehler';
      if (e.payload.detail) msg += ': ' + e.payload.detail;
      if (e.payload.hint) msg += '\nHinweis: ' + e.payload.hint;
      return msg;
    }
    return e.message || String(e);
  }
  function showErrorToast(message, options) {
    options = options || {};
    const id = 'api-toast-container';
    let container = document.getElementById(id);
    if (!container) {
      container = document.createElement('div');
      container.id = id;
      container.style.position = 'fixed';
      container.style.top = '1rem';
      container.style.right = '1rem';
      container.style.zIndex = '1080';
      document.body.appendChild(container);
    }
    if (window.bootstrap && bootstrap.Toast) {
      const wrapper = document.createElement('div');
      wrapper.className = 'toast align-items-center text-bg-danger border-0 show';
      wrapper.setAttribute('role', 'alert');
      wrapper.setAttribute('aria-live', 'assertive');
      wrapper.setAttribute('aria-atomic', 'true');
      wrapper.innerHTML =
        '<div class="d-flex"><div class="toast-body">' +
        escapeHtml(message).replace(/\n/g, '<br>') +
        '</div><button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button></div>';
      container.appendChild(wrapper);
      setTimeout(() => {
        try {
          wrapper.remove();
        } catch (_) {}
      }, options.duration || 7000);
    } else {
      alert(message);
    }
  }
  function escapeHtml(str) {
    return String(str).replace(
      /[&<>"']/g,
      (s) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[s]
    );
  }
  if (!window.__apiFetchUnhandledListener) {
    window.__apiFetchUnhandledListener = true;
    window.addEventListener('unhandledrejection', (ev) => {
      const r = ev.reason;
      if (r && (r.status || (r.payload && r.payload.error))) {
        try {
          apiShowError(formatError(r));
        } catch (_) {}
      }
    });
  }
  window.apiFetch = apiFetch;
  window.apiFormatError = formatError;
  window.apiShowError = showErrorToast;
})();
